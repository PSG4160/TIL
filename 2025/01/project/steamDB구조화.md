# 프로젝트에서 Steam 데이터를 구조화한 의사결정 과정

### 개요
이 프로젝트는 Steam 데이터를 Django 기반 시스템에 저장하는 과정을 구조화한 것입니다. 주요 목적은 **사용자의 Steam 프로필, 리뷰, 플레이타임 정보를 수집**하여 Django 모델에 저장하는 것이며, 이를 통해 사용자 맞춤형 경험을 제공하거나 통계 자료로 활용하려는 것입니다.

---

### **핵심 구조와 의사결정**
#### 1. **모델 설계**
Steam 데이터를 Django에서 관리하기 위해 `models.py`에 세 가지 주요 모델을 설계했습니다:
1. `SteamProfile`: 사용자의 Steam 계정 정보를 저장.
2. `SteamReview`: 사용자가 작성한 추천 리뷰 중 상위 3개를 저장.
3. `SteamPlaytime`: 사용자가 가장 오래 플레이한 상위 2개 게임 정보를 저장.

#### **의사결정 포인트**
- **연관 모델을 통한 관계 설정**
  - `SteamProfile`은 `Account`와 **1:1 관계**를 가짐.
  - `SteamReview`와 `SteamPlaytime`은 `Account`와 **1:N 관계**를 가짐.
  - 이러한 관계를 통해 사용자와 Steam 데이터를 명확히 연결하고 중복을 방지.
  
- **데이터 필드 최소화**
  - 모델의 필드는 저장이 필요한 최소한의 데이터만 포함:
    - `SteamReview`: 리뷰 게임 ID(`app_id`).
    - `SteamPlaytime`: 게임 ID(`app_id`)와 플레이 시간(`playtime`).
    - 리뷰 텍스트나 상세한 게임 정보는 필요 시 추가 설계 가능.
  - 데이터 크기를 줄이고 효율성을 확보.

---

#### 2. **`steam_data.py`의 구조**
`steam_data.py`는 `management/commands` 디렉토리에 위치한 Django 커맨드로, Steam API 및 Selenium을 활용해 데이터를 수집하고 DB에 저장합니다.

#### **구조화 및 데이터 처리 단계**
1. **Steam 프로필 공개 여부 확인**
   - Steam API(`GetPlayerSummaries`)를 사용해 사용자의 프로필 공개 상태를 확인.
   - 비공개일 경우 관련 데이터를 수집하지 않고 기본값으로 처리.

2. **리뷰 데이터 수집**
   - Selenium WebDriver를 이용해 Steam 커뮤니티 페이지에서 리뷰를 크롤링.
   - 리뷰 중 'Recommended'가 포함된 상위 3개를 저장.
   - 공개 여부 판단이 어렵거나 데이터가 없으면 기본값으로 처리.

3. **플레이타임 데이터 수집**
   - Steam API(`GetOwnedGames`)를 사용해 사용자의 상위 2개 플레이타임 데이터를 수집.
   - API를 통해 효율적으로 데이터를 가져옴으로써 크롤링의 불안정성을 회피.

4. **데이터 저장 및 갱신**
   - **트랜잭션 사용**: 데이터 저장 및 갱신은 원자적(atomic)으로 처리하여 일관성 유지.
   - **중복 방지**: 기존 리뷰와 플레이타임 데이터를 삭제 후 새 데이터로 갱신.
   - **공개 상태 업데이트**: 공개 여부에 따라 `SteamProfile`의 `is_review`, `is_playtime` 필드 갱신.

---

### **의사결정의 이유와 장점**

#### 1. **모델 단순화**
- Steam 데이터는 빈번히 변경될 가능성이 크기 때문에, 최소한의 필드만 설계하여 저장.
- 게임 ID나 간단한 정보만 저장하고, 필요 시 API 호출이나 추가 데이터를 통해 확장 가능.

#### 2. **API와 크롤링의 조화**
- 주요 데이터(프로필, 플레이타임)는 API를 사용해 안정적으로 수집.
- 리뷰는 API로 수집할 수 없으므로 Selenium을 활용한 크롤링으로 보완.
- 이 접근은 데이터 수집의 안정성과 범용성을 모두 충족.

#### 3. **공개 여부 판단을 통한 최적화**
- 사용자의 Steam 계정이 비공개라면 데이터를 수집하지 않고 기본값으로 처리.
- 불필요한 API 호출 및 크롤링 작업을 줄여 성능 최적화.

#### 4. **트랜잭션 기반 데이터 저장**
- 트랜잭션(`transaction.atomic`)을 사용하여 데이터 무결성을 유지.
- 기존 데이터를 삭제 후 저장함으로써 중복과 불필요한 데이터 누적을 방지.

---

### **구조화 과정이 주는 교훈**
1. **데이터베이스 모델링**
   - 간단하면서도 확장 가능한 구조를 설계하는 것이 중요.
   - 관계형 데이터베이스의 장점을 살려 중복 데이터를 방지.

2. **효율적인 데이터 수집**
   - API와 크롤링을 적절히 활용해 데이터 수집의 안정성과 다양성을 확보.
   - 공개 상태를 미리 확인해 비효율적인 작업을 줄임.

3. **데이터 저장 로직의 안정성**
   - 원자적 트랜잭션을 사용해 데이터 무결성을 유지.
   - 기존 데이터를 삭제 후 저장함으로써 중복과 불필요한 데이터 누적을 방지.

---

### 결론
이 프로젝트는 **효율적인 데이터 수집과 관리**를 목표로 API, 크롤링, DB 모델링, 트랜잭션 등을 적절히 활용했습니다. 이러한 구조화는 **확장성과 안정성을 동시에 만족**하며, Steam 데이터를 활용한 다양한 서비스 개발을 가능하게 합니다.

**향후 발전 방향**
- 리뷰 텍스트와 같은 추가 데이터 필드를 저장하여 사용자 경험을 개선.
- 플레이타임 데이터를 기반으로 게임 추천 알고리즘을 구현.
- 크롤링 의존성을 줄이고 API를 확장적으로 활용하는 방향으로 개선.

